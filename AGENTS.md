# Repository Guidelines

This guide provides essential information for AI coding agents working in the
kitsunejs repository. For full details, see `STYLE_GUIDE.md` and
`CONTRIBUTING.md`.

---

## Project Structure & Module Organization

- `src/`: Library source code
  - `src/index.ts`: Public entry point (re-exports all public APIs)
  - `src/core/`: Core types (`option.ts`, `result.ts`, `errors.ts`)
- `tests/`: Vitest test files
  - `*.test.ts`: Runtime behavior tests
  - `*.test-d.ts`: Type-level tests (validated via Vitest typecheck)
- `docs/`: User-facing documentation (`api-reference.md`, `recipes.md`,
  `rust-comparison.md`)
- `dist/`: Build output (generated by tsup). Do not edit manually.

---

## Build, Test, and Development Commands

**Prerequisites**: Node.js 22+ and `pnpm@10.20.0` (see `package.json`)

### Essential Commands

```bash
pnpm install         # Install dependencies
pnpm type-check      # TypeScript type checking (tsc --noEmit)
pnpm lint            # Biome lint + format verification
pnpm format          # Auto-fix formatting and import organization
pnpm test            # Run all tests (includes typecheck)
pnpm test:coverage   # Generate coverage report (text/json/html)
pnpm build           # Bundle to dist/ (ESM + CJS + .d.ts)
```

### Running Single Tests

```bash
# Run a specific test file
pnpm test -- tests/core/result.test.ts

# Run a specific test file in watch mode
pnpm test -- tests/core/option.test.ts --watch
```

### Pre-commit Checklist

Before committing or opening a PR, run:

```bash
pnpm lint && pnpm type-check && pnpm test && pnpm build
```

---

## Code Style Guidelines

### Formatting & Syntax

- **Indentation**: 2 spaces (see `.editorconfig`)
- **Line length**: Max 80 characters
- **Quotes**: Double quotes for strings (enforced by Biome)
- **Module system**: ESM (`"type": "module"` in package.json)
- **Semicolons**: Required (Biome default)
- **Imports**: Organize imports automatically via Biome

### Import Guidelines

```typescript
// Use .js extensions for local imports (required for ESM)
import { UnwrapError } from "@/core/errors.js";

// Separate type imports
import type { Option as OptionType } from "@/core/option.js";

// Path alias @ maps to src/
import { Result } from "@/core/result.js";
```

### Type Definitions

**ALWAYS use `type`, NEVER use `interface`**

```typescript
// ✅ Good
type User = {
  name: string;
  age: number;
};

// ❌ Bad
interface User {
  name: string;
  age: number;
}
```

### Functions

- Use `function` declarations for top-level functions
- Arrow functions are allowed for callbacks/arguments
- Always specify return types explicitly

```typescript
// ✅ Good - top-level function
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// ✅ Good - arrow function as callback
const doubled = numbers.map((n) => n * 2);

// ❌ Bad - arrow function at top level
const calculateTotal = (items: Item[]): number => {
  return items.reduce((sum, item) => sum + item.price, 0);
};
```

### Naming Conventions

| Type               | Convention   | Example                          |
| ------------------ | ------------ | -------------------------------- |
| Variables          | `camelCase`  | `userName`, `totalCount`         |
| Functions          | `camelCase`  | `calculateTotal()`, `unwrapOr()` |
| Types              | `PascalCase` | `User`, `Result`, `OptionType`   |
| Classes            | `PascalCase` | `ResultImpl`, `Ok`, `Err`        |
| Constants          | `UPPER_CASE` | `MAX_RETRY_COUNT`                |
| Private properties | `_camelCase` | `_value`, `_isOk`                |

### Error Handling

- **NEVER use `any`** - use `unknown` or generics instead
- Use `async/await` for async code (avoid `.then()/.catch()` chains)
- Handle exceptions explicitly (no silent failures)
- Prefer `Result` type for expected errors

```typescript
// ✅ Good
function parseJSON<T>(json: string): Result<T, Error> {
  return Result.try(() => JSON.parse(json) as T);
}

// ❌ Bad - uses any
function parseJSON(json: string): any {
  return JSON.parse(json);
}
```

---

## Testing Guidelines

### Test File Structure

- Mirror source structure: `tests/core/result.test.ts` ↔ `src/core/result.ts`
- Runtime tests: `*.test.ts`
- Type tests: `*.test-d.ts`

### Test Naming

```typescript
describe("Result.map", () => {
  it("should transform Ok value", () => {
    const result = Result.ok(5).map((x) => x * 2);
    expect(result.unwrap()).toBe(10);
  });

  it("should preserve Err value", () => {
    const result = Result.err("error").map((x) => x * 2);
    expect(result.isErr()).toBe(true);
  });
});
```

### Coverage Expectations

- Target 90%+ code coverage
- Test edge cases and error paths
- Add type tests for public API changes

---

## Commit & Pull Request Guidelines

### Commit Format (Conventional Commits)

```
<type>(<scope>): <subject>

Examples:
  feat(result): add flatten method for nested Results
  fix(option): handle None in andThen correctly
  docs: update API reference with new examples
  refactor(result): simplify error handling logic
  test(option): add edge cases for unwrap methods
```

**Types**: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### Pull Request Guidelines

- Keep PRs **small and focused** (one feature/fix per PR)
- Fill out the PR template (`.github/PULL_REQUEST_TEMPLATE.md`)
- Link related issues (e.g., "Closes #123")
- Ensure all checks pass before requesting review

---

## Documentation

### JSDoc Requirements

All public APIs must include JSDoc comments with:

- Description of functionality
- `@template` tags for generics
- `@param` tags for parameters
- `@returns` tag for return value
- `@example` with code samples

```typescript
/**
 * Maps a Result<T, E> to Result<U, E> by applying a function to Ok value.
 *
 * @template U - The type of the transformed value
 * @param fn - The function to apply to the Ok value
 * @returns A new Result with the transformed value, or the original Err
 *
 * @example
 * ```typescript
 * const result = Result.ok(5);
 * const doubled = result.map(x => x * 2);
 * console.log(doubled.unwrap()); // 10
 * ```
 */
abstract map<U>(fn: (value: T) => U): Result<U, E>;
```

---

## Quick Reference

**Need to see existing patterns?** Check these files:

- Type definitions: `src/core/result.ts`, `src/core/option.ts`
- Tests: `tests/core/result.test.ts`, `tests/core/option.test.ts`
- Full style guide: `STYLE_GUIDE.md` (556 lines with detailed examples)
- Contributing guide: `CONTRIBUTING.md`
