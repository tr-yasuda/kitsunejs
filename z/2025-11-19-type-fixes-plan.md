# kitsunejs 型エラー改善プラン（暫定ドラフト）

作成日: 2025-11-19

このプランは、ユーザーのサンプルが型エラー無しで動作するよう、`kitsunejs` の型定義／API／ドキュメントを整理・改善するための提案です。まずは複数案を提示し、Pros/Cons を明記します。最後に推奨案と進め方、確認事項をまとめます。

---

## 背景と現状仮説

- 現在の `Result.err` のシグネチャは `static err<T = never, E = unknown>(error: E): Result<T, E>`。
- `Result.err("...")` のままでは `T = never` となり、`unwrapOr(0)` の型 `T` に `number` を渡せず型エラーになりがち。
- ユーザーは `Result.err<number>("...")` として `T` を明示することで回避している。
- 目的: `Result.err('...').unwrapOr(0)` のような自然な書き方で型エラーを発生させない、もしくはドキュメント全体で一貫した書き方を提示すること。

---

## 解決方針の選択肢

### 案A: ドキュメントの記法統一（コードは現状維持）

- 内容:
  - README / docs のサンプルを、`Err` の場面で必ず `T` を明示する書き方に統一。
  - 例: `Result.err<number>('...').unwrapOr(0)`。
- Pros:
  - コード変更不要。後方互換性・リスクが最小。
  - 現行の厳密な型安全性（`T` が既知であることを強制）を維持。
- Cons:
  - 利便性がやや低い（毎回 `T` を明示する必要）。
  - 既存ユーザーが直感的に書いたコードで型エラーが出やすい。

### 案B: `unwrapOr`/`unwrapOrElse` をユニオン型に拡張（利便性優先）

- 変更案（概念）:
  - `unwrapOr<U>(defaultValue: U): T | U`
  - `unwrapOrElse<U>(fn: (error: E) => U): T | U`
- 期待効果:
  - `Result.err('...').unwrapOr(0)` が `number` と `T` のユニオンで型通過。`Err<never>` でも OK。
- Pros:
  - `T` を都度明示しなくても実用上ほぼ困らない。
  - 既存コードの多くが自然に通るようになる。
- Cons:
  - 戻り型が `T | U` になるため、後続で追加の型絞りが必要になるケースがある。
  - API の表現力が増す分、やや学習コストが上がる可能性。

### 案C: `Result.err` の既定型を `unknown` へ変更（妥協型）

- 変更案（概念）:
  - `static err<T = unknown, E = unknown>(error: E): Result<T, E>`
- 期待効果:
  - `unwrapOr(0)` の `defaultValue: T` に `number` を渡せる（`T=unknown` なら `number` は代入可能）。
- Pros:
  - `unwrapOr` の戻り値の型は依然として `T`（= `unknown`）であり、ユニオン化を避けられる。
  - 使い勝手は一定改善。
- Cons:
  - `unwrap()` などで得られる `T` が `unknown` になりやすく、型安全性が緩む。
  - 実態として「型が未確定」のまま流通しやすい。

### 案D: ヘルパー API の追加（現状維持 + 選択的利便性）

- 変更案（概念）:
  - `Result.errOf<T>(error: E): Result<T, E>` を追加（既存の `err` はそのまま）。
  - README での推奨記法を `Result.errOf<number>('...')` に統一。
- Pros:
  - 既存 API は非破壊、選択肢を増やすだけ。
  - 利便性と明示性のバランスを取りやすい。
- Cons:
  - API 表面積がやや増える。
  - 本質的には案Aの「明示」スタイルの別表現。

---

## 推奨案

段階的アプローチを推奨します。

1. 最短での不便解消: 案B（`unwrapOr`/`unwrapOrElse` をユニオン化）を適用。
   - ユーザーが最も自然に書きたいであろう `Result.err('...').unwrapOr(0)` を許容しつつ、型の破綻は避ける。
   - 既存のコードに対する破壊的変更は限定的（戻り値がユニオンになる点は注意喚起）。
2. ドキュメント整備: 「型がユニオンになるケース」のガイダンスを README / API Reference に追加。
3. 将来的選択肢の余地として、案D（`errOf` の追加）を検討・併記。

注: 案Cは型安全性低下の方向、案Aはユーザー体験の改善に弱い、ため第1優先は案Bとします。

---

## 実施タスク（詳細）

1. 現状調査と再現
   - tsc 型チェック、tsup ビルド、vitest テストでの型エラー有無を確認。
   - README / docs（`api-reference.md`, `recipes.md`, `rust-comparison.md`）のサンプルをファイル化し、型チェックを実施。

2. 型設計の見直し（案B実装）
   - `Result<T, E>`:
     - `unwrapOr<U>(defaultValue: U): T | U`
     - `unwrapOrElse<U>(fn: (error: E) => U): T | U`
   - `Ok` / `Err` 実装クラスでの戻り型を統一。
   - 既存の `map` / `mapErr` / `and` / `or` / `andThen` / `orElse` / `toOption` は非変更（必要時のみ最小修正）。

3. ドキュメント更新
   - サンプルコードがすべて型エラー無しで動くよう修正。
   - ユニオン戻りの注意点（後段処理での型ガードや既定値の型一貫性）を追記。

4. 検証
   - tsc, tsup, vitest の再実行。
   - サンプル実行（Node ESM）での動作確認。

5. 代替案の保留/選択（必要に応じて）
   - `Result.errOf<T>(error)` を別途追加（案D）。
   - 利用ガイドラインの追記（`z/coding-guidelines.md` へ必要事項を反映）。

6. 変更履歴の記録
   - このプランとの差分と理由を `z/` に追記。

---

## ユーザー確認事項（必ずご回答ください）

1) 期待する書き方はどちらですか？
   - a. `Result.err('...').unwrapOr(0)` をエラー無しで許容してほしい（戻り値がユニオンでもOK）
   - b. 常に `Result.err<number>('...')` のように `T` を明示するスタイルで良い（ドキュメント統一のみでOK）

2) 既存の戻り値がユニオン型（`T | U`）になることへの許容度は？
   - a. 許容できる（利便性重視）
   - b. 好ましくない（厳格性重視）

3) API 表面積拡大の可否
   - `Result.errOf<T>(error)` のようなヘルパー追加を受け入れますか？

4) 対応優先度
   - ドキュメント修正のみで早期クローズ可か、それともライブラリ側の型改善まで対応したいか？

---

## 想定スケジュール（ユーザー回答後）

- Day 0: 回答に基づき最終案確定、実装着手。
- Day 1: 型変更（案B）実装、ドキュメント更新、tsc/tsup/vitest 通過。
- Day 2: レビュー対応、微調整、パッチリリース準備。

---

## 参考メモ

- `Result.err` で `T` を推論させるのは TS の型システム上困難（`unwrapOr` など後続呼び出しからインスタンスの型パラメータを遡及推論できない）。
- そのため、多くのライブラリでは `unwrapOr` の戻りをユニオン化するか、利用側で `T` を明示する設計が一般的です。
